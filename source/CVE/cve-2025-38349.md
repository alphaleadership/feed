---
title: CVE-2025-38349
date: 2025-7-18
lien: "https://cvefeed.io/vuln/detail/CVE-2025-38349"
categories:
  - cve
---

CVE ID : CVE-2025-38349

Published :  July 18
2025
8:15 a.m. | 7 hours
59 minutes ago

Description : In the Linux kernel
the following vulnerability has been resolved:

eventpoll: don't decrement ep refcount while still holding the ep mutex

Jann Horn points out that epoll is decrementing the ep refcount and then
doing a

    mutex_unlock(&ep->mtx);

afterwards. That's very wrong
because it can lead to a use-after-free.

That pattern is actually fine for the very last reference
because the
code in question will delay the actual call to "ep_free(ep)" until after
it has unlocked the mutex.

But it's wrong for the much subtler "next to last" case when somebody
*else* may also be dropping their reference and free the ep while we're
still using the mutex.

Note that this is true even if that other user is also using the same ep
mutex: mutexes
unlike spinlocks
can not be used for object ownership
even if they guarantee mutual exclusion.

A mutex "unlock" operation is not atomic
and as one user is still
accessing the mutex as part of unlocking it
another user can come in
and get the now released mutex and free the data structure while the
first user is still cleaning up.

See our mutex documentation in Documentation/locking/mutex-design.rst
in particular the section [1] about semantics:

	"mutex_unlock() may access the mutex structure even after it has
	 internally released the lock already - so it's not safe for
	 another context to acquire the mutex and assume that the
	 mutex_unlock() context is not using the structure anymore"

So if we drop our ep ref before the mutex unlock
but we weren't the
last one
we may then unlock the mutex
another user comes in
drops
_their_ reference and releases the 'ep' as it now has no users - all
while the mutex_unlock() is still accessing it.

Fix this by simply moving the ep refcount dropping to outside the mutex:
the refcount itself is atomic
and doesn't need mutex protection (that's
the whole _point_ of refcounts: unlike mutexes
they are inherently
about object lifetimes).

Severity: 0.0 | NA

Visit the link for more details
such as CVSS details
affected products
timeline
and more...
